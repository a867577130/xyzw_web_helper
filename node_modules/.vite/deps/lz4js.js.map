{
  "version": 3,
  "sources": ["../../lz4js/util.js", "../../lz4js/xxh32.js", "../../lz4js/lz4.js"],
  "sourcesContent": ["// Simple hash function, from: http://burtleburtle.net/bob/hash/integer.html.\n// Chosen because it doesn't use multiply and achieves full avalanche.\nexports.hashU32 = function hashU32 (a) {\n  a = a | 0;\n  a = a + 2127912214 + (a << 12) | 0;\n  a = a ^ -949894596 ^ a >>> 19;\n  a = a + 374761393 + (a << 5) | 0;\n  a = a + -744332180 ^ a << 9;\n  a = a + -42973499 + (a << 3) | 0;\n  return a ^ -1252372727 ^ a >>> 16 | 0;\n};\n\n// Reads a 64-bit little-endian integer from an array.\nexports.readU64 = function readU64 (b, n) {\n  var x = 0;\n  x |= b[n++] << 0;\n  x |= b[n++] << 8;\n  x |= b[n++] << 16;\n  x |= b[n++] << 24;\n  x |= b[n++] << 32;\n  x |= b[n++] << 40;\n  x |= b[n++] << 48;\n  x |= b[n++] << 56;\n  return x;\n};\n\n// Reads a 32-bit little-endian integer from an array.\nexports.readU32 = function readU32 (b, n) {\n  var x = 0;\n  x |= b[n++] << 0;\n  x |= b[n++] << 8;\n  x |= b[n++] << 16;\n  x |= b[n++] << 24;\n  return x;\n};\n\n// Writes a 32-bit little-endian integer from an array.\nexports.writeU32 = function writeU32 (b, n, x) {\n  b[n++] = (x >> 0) & 0xff;\n  b[n++] = (x >> 8) & 0xff;\n  b[n++] = (x >> 16) & 0xff;\n  b[n++] = (x >> 24) & 0xff;\n};\n\n// Multiplies two numbers using 32-bit integer multiplication.\n// Algorithm from Emscripten.\nexports.imul = function imul (a, b) {\n  var ah = a >>> 16;\n  var al = a & 65535;\n  var bh = b >>> 16;\n  var bl = b & 65535;\n\n  return al * bl + (ah * bl + al * bh << 16) | 0;\n};\n", "// xxh32.js - implementation of xxhash32 in plain JavaScript\nvar util = require('./util.js');\n\n// xxhash32 primes\nvar prime1 = 0x9e3779b1;\nvar prime2 = 0x85ebca77;\nvar prime3 = 0xc2b2ae3d;\nvar prime4 = 0x27d4eb2f;\nvar prime5 = 0x165667b1;\n\n// Utility functions/primitives\n// --\n\nfunction rotl32 (x, r) {\n  x = x | 0;\n  r = r | 0;\n\n  return x >>> (32 - r | 0) | x << r | 0;\n}\n\nfunction rotmul32 (h, r, m) {\n  h = h | 0;\n  r = r | 0;\n  m = m | 0;\n\n  return util.imul(h >>> (32 - r | 0) | h << r, m) | 0;\n}\n\nfunction shiftxor32 (h, s) {\n  h = h | 0;\n  s = s | 0;\n\n  return h >>> s ^ h | 0;\n}\n\n// Implementation\n// --\n\nfunction xxhapply (h, src, m0, s, m1) {\n  return rotmul32(util.imul(src, m0) + h, s, m1);\n}\n\nfunction xxh1 (h, src, index) {\n  return rotmul32((h + util.imul(src[index], prime5)), 11, prime1);\n}\n\nfunction xxh4 (h, src, index) {\n  return xxhapply(h, util.readU32(src, index), prime3, 17, prime4);\n}\n\nfunction xxh16 (h, src, index) {\n  return [\n    xxhapply(h[0], util.readU32(src, index + 0), prime2, 13, prime1),\n    xxhapply(h[1], util.readU32(src, index + 4), prime2, 13, prime1),\n    xxhapply(h[2], util.readU32(src, index + 8), prime2, 13, prime1),\n    xxhapply(h[3], util.readU32(src, index + 12), prime2, 13, prime1)\n  ];\n}\n\nfunction xxh32 (seed, src, index, len) {\n  var h, l;\n  l = len;\n  if (len >= 16) {\n    h = [\n      seed + prime1 + prime2,\n      seed + prime2,\n      seed,\n      seed - prime1\n    ];\n\n    while (len >= 16) {\n      h = xxh16(h, src, index);\n\n      index += 16;\n      len -= 16;\n    }\n\n    h = rotl32(h[0], 1) + rotl32(h[1], 7) + rotl32(h[2], 12) + rotl32(h[3], 18) + l;\n  } else {\n    h = (seed + prime5 + len) >>> 0;\n  }\n\n  while (len >= 4) {\n    h = xxh4(h, src, index);\n\n    index += 4;\n    len -= 4;\n  }\n\n  while (len > 0) {\n    h = xxh1(h, src, index);\n\n    index++;\n    len--;\n  }\n\n  h = shiftxor32(util.imul(shiftxor32(util.imul(shiftxor32(h, 15), prime2), 13), prime3), 16);\n\n  return h >>> 0;\n}\n\nexports.hash = xxh32;\n", "// lz4.js - An implementation of Lz4 in plain JavaScript.\n//\n// TODO:\n// - Unify header parsing/writing.\n// - Support options (block size, checksums)\n// - Support streams\n// - Better error handling (handle bad offset, etc.)\n// - HC support (better search algorithm)\n// - Tests/benchmarking\n\nvar xxhash = require('./xxh32.js');\nvar util = require('./util.js');\n\n// Constants\n// --\n\n// Compression format parameters/constants.\nvar minMatch = 4;\nvar minLength = 13;\nvar searchLimit = 5;\nvar skipTrigger = 6;\nvar hashSize = 1 << 16;\n\n// Token constants.\nvar mlBits = 4;\nvar mlMask = (1 << mlBits) - 1;\nvar runBits = 4;\nvar runMask = (1 << runBits) - 1;\n\n// Shared buffers\nvar blockBuf = makeBuffer(5 << 20);\nvar hashTable = makeHashTable();\n\n// Frame constants.\nvar magicNum = 0x184D2204;\n\n// Frame descriptor flags.\nvar fdContentChksum = 0x4;\nvar fdContentSize = 0x8;\nvar fdBlockChksum = 0x10;\n// var fdBlockIndep = 0x20;\nvar fdVersion = 0x40;\nvar fdVersionMask = 0xC0;\n\n// Block sizes.\nvar bsUncompressed = 0x80000000;\nvar bsDefault = 7;\nvar bsShift = 4;\nvar bsMask = 7;\nvar bsMap = {\n  4: 0x10000,\n  5: 0x40000,\n  6: 0x100000,\n  7: 0x400000\n};\n\n// Utility functions/primitives\n// --\n\n// Makes our hashtable. On older browsers, may return a plain array.\nfunction makeHashTable () {\n  try {\n    return new Uint32Array(hashSize);\n  } catch (error) {\n    var hashTable = new Array(hashSize);\n\n    for (var i = 0; i < hashSize; i++) {\n      hashTable[i] = 0;\n    }\n\n    return hashTable;\n  }\n}\n\n// Clear hashtable.\nfunction clearHashTable (table) {\n  for (var i = 0; i < hashSize; i++) {\n    hashTable[i] = 0;\n  }\n}\n\n// Makes a byte buffer. On older browsers, may return a plain array.\nfunction makeBuffer (size) {\n  try {\n    return new Uint8Array(size);\n  } catch (error) {\n    var buf = new Array(size);\n\n    for (var i = 0; i < size; i++) {\n      buf[i] = 0;\n    }\n\n    return buf;\n  }\n}\n\nfunction sliceArray (array, start, end) {\n  if (typeof array.buffer !== undefined) {\n    if (Uint8Array.prototype.slice) {\n      return array.slice(start, end);\n    } else {\n      // Uint8Array#slice polyfill.\n      var len = array.length;\n\n      // Calculate start.\n      start = start | 0;\n      start = (start < 0) ? Math.max(len + start, 0) : Math.min(start, len);\n\n      // Calculate end.\n      end = (end === undefined) ? len : end | 0;\n      end = (end < 0) ? Math.max(len + end, 0) : Math.min(end, len);\n\n      // Copy into new array.\n      var arraySlice = new Uint8Array(end - start);\n      for (var i = start, n = 0; i < end;) {\n        arraySlice[n++] = array[i++];\n      }\n\n      return arraySlice;\n    }\n  } else {\n    // Assume normal array.\n    return array.slice(start, end);\n  }\n}\n\n// Implementation\n// --\n\n// Calculates an upper bound for lz4 compression.\nexports.compressBound = function compressBound (n) {\n  return (n + (n / 255) + 16) | 0;\n};\n\n// Calculates an upper bound for lz4 decompression, by reading the data.\nexports.decompressBound = function decompressBound (src) {\n  var sIndex = 0;\n\n  // Read magic number\n  if (util.readU32(src, sIndex) !== magicNum) {\n    throw new Error('invalid magic number');\n  }\n\n  sIndex += 4;\n\n  // Read descriptor\n  var descriptor = src[sIndex++];\n\n  // Check version\n  if ((descriptor & fdVersionMask) !== fdVersion) {\n    throw new Error('incompatible descriptor version ' + (descriptor & fdVersionMask));\n  }\n\n  // Read flags\n  var useBlockSum = (descriptor & fdBlockChksum) !== 0;\n  var useContentSize = (descriptor & fdContentSize) !== 0;\n\n  // Read block size\n  var bsIdx = (src[sIndex++] >> bsShift) & bsMask;\n\n  if (bsMap[bsIdx] === undefined) {\n    throw new Error('invalid block size ' + bsIdx);\n  }\n\n  var maxBlockSize = bsMap[bsIdx];\n\n  // Get content size\n  if (useContentSize) {\n    return util.readU64(src, sIndex);\n  }\n\n  // Checksum\n  sIndex++;\n\n  // Read blocks.\n  var maxSize = 0;\n  while (true) {\n    var blockSize = util.readU32(src, sIndex);\n    sIndex += 4;\n\n    if (blockSize & bsUncompressed) {\n      blockSize &= ~bsUncompressed;\n      maxSize += blockSize;\n    } else {\n      maxSize += maxBlockSize;\n    }\n\n    if (blockSize === 0) {\n      return maxSize;\n    }\n\n    if (useBlockSum) {\n      sIndex += 4;\n    }\n\n    sIndex += blockSize;\n  }\n};\n\n// Creates a buffer of a given byte-size, falling back to plain arrays.\nexports.makeBuffer = makeBuffer;\n\n// Decompresses a block of Lz4.\nexports.decompressBlock = function decompressBlock (src, dst, sIndex, sLength, dIndex) {\n  var mLength, mOffset, sEnd, n, i;\n\n  // Setup initial state.\n  sEnd = sIndex + sLength;\n\n  // Consume entire input block.\n  while (sIndex < sEnd) {\n    var token = src[sIndex++];\n\n    // Copy literals.\n    var literalCount = (token >> 4);\n    if (literalCount > 0) {\n      // Parse length.\n      if (literalCount === 0xf) {\n        while (true) {\n          literalCount += src[sIndex];\n          if (src[sIndex++] !== 0xff) {\n            break;\n          }\n        }\n      }\n\n      // Copy literals\n      for (n = sIndex + literalCount; sIndex < n;) {\n        dst[dIndex++] = src[sIndex++];\n      }\n    }\n\n    if (sIndex >= sEnd) {\n      break;\n    }\n\n    // Copy match.\n    mLength = (token & 0xf);\n\n    // Parse offset.\n    mOffset = src[sIndex++] | (src[sIndex++] << 8);\n\n    // Parse length.\n    if (mLength === 0xf) {\n      while (true) {\n        mLength += src[sIndex];\n        if (src[sIndex++] !== 0xff) {\n          break;\n        }\n      }\n    }\n\n    mLength += minMatch;\n\n    // Copy match.\n    for (i = dIndex - mOffset, n = i + mLength; i < n;) {\n      dst[dIndex++] = dst[i++] | 0;\n    }\n  }\n\n  return dIndex;\n};\n\n// Compresses a block with Lz4.\nexports.compressBlock = function compressBlock (src, dst, sIndex, sLength, hashTable) {\n  var mIndex, mAnchor, mLength, mOffset, mStep;\n  var literalCount, dIndex, sEnd, n;\n\n  // Setup initial state.\n  dIndex = 0;\n  sEnd = sLength + sIndex;\n  mAnchor = sIndex;\n\n  // Process only if block is large enough.\n  if (sLength >= minLength) {\n    var searchMatchCount = (1 << skipTrigger) + 3;\n\n    // Consume until last n literals (Lz4 spec limitation.)\n    while (sIndex + minMatch < sEnd - searchLimit) {\n      var seq = util.readU32(src, sIndex);\n      var hash = util.hashU32(seq) >>> 0;\n\n      // Crush hash to 16 bits.\n      hash = ((hash >> 16) ^ hash) >>> 0 & 0xffff;\n\n      // Look for a match in the hashtable. NOTE: remove one; see below.\n      mIndex = hashTable[hash] - 1;\n\n      // Put pos in hash table. NOTE: add one so that zero = invalid.\n      hashTable[hash] = sIndex + 1;\n\n      // Determine if there is a match (within range.)\n      if (mIndex < 0 || ((sIndex - mIndex) >>> 16) > 0 || util.readU32(src, mIndex) !== seq) {\n        mStep = searchMatchCount++ >> skipTrigger;\n        sIndex += mStep;\n        continue;\n      }\n\n      searchMatchCount = (1 << skipTrigger) + 3;\n\n      // Calculate literal count and offset.\n      literalCount = sIndex - mAnchor;\n      mOffset = sIndex - mIndex;\n\n      // We've already matched one word, so get that out of the way.\n      sIndex += minMatch;\n      mIndex += minMatch;\n\n      // Determine match length.\n      // N.B.: mLength does not include minMatch, Lz4 adds it back\n      // in decoding.\n      mLength = sIndex;\n      while (sIndex < sEnd - searchLimit && src[sIndex] === src[mIndex]) {\n        sIndex++;\n        mIndex++;\n      }\n      mLength = sIndex - mLength;\n\n      // Write token + literal count.\n      var token = mLength < mlMask ? mLength : mlMask;\n      if (literalCount >= runMask) {\n        dst[dIndex++] = (runMask << mlBits) + token;\n        for (n = literalCount - runMask; n >= 0xff; n -= 0xff) {\n          dst[dIndex++] = 0xff;\n        }\n        dst[dIndex++] = n;\n      } else {\n        dst[dIndex++] = (literalCount << mlBits) + token;\n      }\n\n      // Write literals.\n      for (var i = 0; i < literalCount; i++) {\n        dst[dIndex++] = src[mAnchor + i];\n      }\n\n      // Write offset.\n      dst[dIndex++] = mOffset;\n      dst[dIndex++] = (mOffset >> 8);\n\n      // Write match length.\n      if (mLength >= mlMask) {\n        for (n = mLength - mlMask; n >= 0xff; n -= 0xff) {\n          dst[dIndex++] = 0xff;\n        }\n        dst[dIndex++] = n;\n      }\n\n      // Move the anchor.\n      mAnchor = sIndex;\n    }\n  }\n\n  // Nothing was encoded.\n  if (mAnchor === 0) {\n    return 0;\n  }\n\n  // Write remaining literals.\n  // Write literal token+count.\n  literalCount = sEnd - mAnchor;\n  if (literalCount >= runMask) {\n    dst[dIndex++] = (runMask << mlBits);\n    for (n = literalCount - runMask; n >= 0xff; n -= 0xff) {\n      dst[dIndex++] = 0xff;\n    }\n    dst[dIndex++] = n;\n  } else {\n    dst[dIndex++] = (literalCount << mlBits);\n  }\n\n  // Write literals.\n  sIndex = mAnchor;\n  while (sIndex < sEnd) {\n    dst[dIndex++] = src[sIndex++];\n  }\n\n  return dIndex;\n};\n\n// Decompresses a frame of Lz4 data.\nexports.decompressFrame = function decompressFrame (src, dst) {\n  var useBlockSum, useContentSum, useContentSize, descriptor;\n  var sIndex = 0;\n  var dIndex = 0;\n\n  // Read magic number\n  if (util.readU32(src, sIndex) !== magicNum) {\n    throw new Error('invalid magic number');\n  }\n\n  sIndex += 4;\n\n  // Read descriptor\n  descriptor = src[sIndex++];\n\n  // Check version\n  if ((descriptor & fdVersionMask) !== fdVersion) {\n    throw new Error('incompatible descriptor version');\n  }\n\n  // Read flags\n  useBlockSum = (descriptor & fdBlockChksum) !== 0;\n  useContentSum = (descriptor & fdContentChksum) !== 0;\n  useContentSize = (descriptor & fdContentSize) !== 0;\n\n  // Read block size\n  var bsIdx = (src[sIndex++] >> bsShift) & bsMask;\n\n  if (bsMap[bsIdx] === undefined) {\n    throw new Error('invalid block size');\n  }\n\n  if (useContentSize) {\n    // TODO: read content size\n    sIndex += 8;\n  }\n\n  sIndex++;\n\n  // Read blocks.\n  while (true) {\n    var compSize;\n\n    compSize = util.readU32(src, sIndex);\n    sIndex += 4;\n\n    if (compSize === 0) {\n      break;\n    }\n\n    if (useBlockSum) {\n      // TODO: read block checksum\n      sIndex += 4;\n    }\n\n    // Check if block is compressed\n    if ((compSize & bsUncompressed) !== 0) {\n      // Mask off the 'uncompressed' bit\n      compSize &= ~bsUncompressed;\n\n      // Copy uncompressed data into destination buffer.\n      for (var j = 0; j < compSize; j++) {\n        dst[dIndex++] = src[sIndex++];\n      }\n    } else {\n      // Decompress into blockBuf\n      dIndex = exports.decompressBlock(src, dst, sIndex, compSize, dIndex);\n      sIndex += compSize;\n    }\n  }\n\n  if (useContentSum) {\n    // TODO: read content checksum\n    sIndex += 4;\n  }\n\n  return dIndex;\n};\n\n// Compresses data to an Lz4 frame.\nexports.compressFrame = function compressFrame (src, dst) {\n  var dIndex = 0;\n\n  // Write magic number.\n  util.writeU32(dst, dIndex, magicNum);\n  dIndex += 4;\n\n  // Descriptor flags.\n  dst[dIndex++] = fdVersion;\n  dst[dIndex++] = bsDefault << bsShift;\n\n  // Descriptor checksum.\n  dst[dIndex] = xxhash.hash(0, dst, 4, dIndex - 4) >> 8;\n  dIndex++;\n\n  // Write blocks.\n  var maxBlockSize = bsMap[bsDefault];\n  var remaining = src.length;\n  var sIndex = 0;\n\n  // Clear the hashtable.\n  clearHashTable(hashTable);\n\n  // Split input into blocks and write.\n  while (remaining > 0) {\n    var compSize = 0;\n    var blockSize = remaining > maxBlockSize ? maxBlockSize : remaining;\n\n    compSize = exports.compressBlock(src, blockBuf, sIndex, blockSize, hashTable);\n\n    if (compSize > blockSize || compSize === 0) {\n      // Output uncompressed.\n      util.writeU32(dst, dIndex, 0x80000000 | blockSize);\n      dIndex += 4;\n\n      for (var z = sIndex + blockSize; sIndex < z;) {\n        dst[dIndex++] = src[sIndex++];\n      }\n\n      remaining -= blockSize;\n    } else {\n      // Output compressed.\n      util.writeU32(dst, dIndex, compSize);\n      dIndex += 4;\n\n      for (var j = 0; j < compSize;) {\n        dst[dIndex++] = blockBuf[j++];\n      }\n\n      sIndex += blockSize;\n      remaining -= blockSize;\n    }\n  }\n\n  // Write blank end block.\n  util.writeU32(dst, dIndex, 0);\n  dIndex += 4;\n\n  return dIndex;\n};\n\n// Decompresses a buffer containing an Lz4 frame. maxSize is optional; if not\n// provided, a maximum size will be determined by examining the data. The\n// buffer returned will always be perfectly-sized.\nexports.decompress = function decompress (src, maxSize) {\n  var dst, size;\n\n  if (maxSize === undefined) {\n    maxSize = exports.decompressBound(src);\n  }\n\n  dst = exports.makeBuffer(maxSize);\n  size = exports.decompressFrame(src, dst);\n\n  if (size !== maxSize) {\n    dst = sliceArray(dst, 0, size);\n  }\n\n  return dst;\n};\n\n// Compresses a buffer to an Lz4 frame. maxSize is optional; if not provided,\n// a buffer will be created based on the theoretical worst output size for a\n// given input size. The buffer returned will always be perfectly-sized.\nexports.compress = function compress (src, maxSize) {\n  var dst, size;\n\n  if (maxSize === undefined) {\n    maxSize = exports.compressBound(src.length);\n  }\n\n  dst = exports.makeBuffer(maxSize);\n  size = exports.compressFrame(src, dst);\n\n  if (size !== maxSize) {\n    dst = sliceArray(dst, 0, size);\n  }\n\n  return dst;\n};\n"],
  "mappings": "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",
  "names": ["hashTable"]
}
